package com.zhgame.common.utils;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLHandshakeException;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.apache.commons.lang.StringUtils;
import org.apache.http.HttpEntity;
import org.apache.http.HttpEntityEnclosingRequest;
import org.apache.http.HttpHost;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponse;
import org.apache.http.HttpVersion;
import org.apache.http.NoHttpResponseException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.HttpRequestRetryHandler;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpRequestBase;
import org.apache.http.client.params.ClientPNames;
import org.apache.http.client.params.CookiePolicy;
import org.apache.http.conn.routing.HttpRoute;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.entity.StringEntity;
import org.apache.http.entity.mime.MultipartEntity;
import org.apache.http.entity.mime.content.FileBody;
import org.apache.http.entity.mime.content.StringBody;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.PoolingClientConnectionManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.CoreConnectionPNames;
import org.apache.http.params.CoreProtocolPNames;
import org.apache.http.params.HttpParams;
import org.apache.http.protocol.ExecutionContext;
import org.apache.http.protocol.HttpContext;
import org.apache.http.util.EntityUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.zhgame.common.custom.ErrorCode;
import com.zhgame.common.custom.SystemException;

public class HttpClientUtil {

	private static Logger logger = LoggerFactory.getLogger(HttpClientUtil.class);

	/**
	 * 
	 * 连接池里的最大连接数
	 */
	private static int MAX_TOTAL_CONNECTIONS = 5000;

	/**
	 * 
	 * 每个路由的默认最大连接数，相同连接会使用同一路由
	 */
	private static int MAX_ROUTE_CONNECTIONS = 5000;

	/**
	 * 
	 * 连接超时时间
	 */
	private static int CONNECT_TIMEOUT = 5000;

	/**
	 * 
	 * 套接字超时时间
	 */
	private static final int SOCKET_TIMEOUT = 50000;

	/**
	 * 
	 * 连接池中 连接请求执行被阻塞的超时时间 在并发量很大的情况下，最好设置成和客户端请求超时时间一致，客户端超时后，服务端就不必再进行处理
	 */
	private static long CONN_MANAGER_TIMEOUT = 60000;

	/**
	 * 字符集
	 */
	private static final String DEFAULT_CHARSET = "UTF-8";

	/**
	 * 默认目标主机
	 */
	private static final HttpHost DEFAULT_TARGETHOST = new HttpHost("http://www.qq.com", 80);

	private static DefaultHttpClient httpClient = null;

	private static final String KEY_MAX_TOTAL_CONNECTIONS = "httpclient.max_total_connections";
	private static final String KEY_MAX_ROUTE_CONNECTIONS = "httpclient.max_route_connections";
	private static final String KEY_CONN_MANAGER_TIMEOUT = "httpclient.conn_manager_timeout";
	private static final String KEY_CONNNECT_TIMEOUT = "httpclient.connect_timeout";

	static {
		initParams();
		initHttpClient();
	}

	private static void initParams() {
		if (System.getProperty(KEY_MAX_TOTAL_CONNECTIONS) != null) {
			MAX_TOTAL_CONNECTIONS = Integer.parseInt(System.getProperty(KEY_MAX_TOTAL_CONNECTIONS));
		}
		if (System.getProperty(KEY_MAX_ROUTE_CONNECTIONS) != null) {
			MAX_ROUTE_CONNECTIONS = Integer.parseInt(System.getProperty(KEY_MAX_ROUTE_CONNECTIONS));
		}
		if (System.getProperty(KEY_CONN_MANAGER_TIMEOUT) != null) {
			CONN_MANAGER_TIMEOUT = Long.parseLong(System.getProperty(KEY_CONN_MANAGER_TIMEOUT));
		}
		if (System.getProperty(KEY_CONNNECT_TIMEOUT) != null) {
			CONNECT_TIMEOUT = Integer.parseInt(System.getProperty(KEY_CONNNECT_TIMEOUT));
		}
		logger.info("init params:<MAX_TOTAL_CONNECTIONS:" + MAX_TOTAL_CONNECTIONS + ";MAX_ROUTE_CONNECTIONS:" + MAX_ROUTE_CONNECTIONS
				+ ";CONN_MANAGER_TIMEOUT:" + CONN_MANAGER_TIMEOUT + ">");
	}

	private static PoolingClientConnectionManager initPoolingClientConnectionManager() {
		SchemeRegistry schemeRegistry = new SchemeRegistry();
		PoolingClientConnectionManager cm = new PoolingClientConnectionManager(schemeRegistry);
		cm.setMaxTotal(MAX_TOTAL_CONNECTIONS);
		cm.setDefaultMaxPerRoute(MAX_ROUTE_CONNECTIONS);
		cm.setMaxPerRoute(new HttpRoute(DEFAULT_TARGETHOST), 20); // 设置对目标主机的最大连接数
		return cm;
	}

	private static HttpParams initHttpParams() {
		HttpParams parentParams = new BasicHttpParams();
		parentParams.setParameter(CoreProtocolPNames.PROTOCOL_VERSION, HttpVersion.HTTP_1_1);
		parentParams.setParameter(ClientPNames.DEFAULT_HOST, DEFAULT_TARGETHOST); // 设置默认targetHost
		parentParams.setParameter(ClientPNames.COOKIE_POLICY, CookiePolicy.BROWSER_COMPATIBILITY);
		parentParams.setParameter(ClientPNames.CONN_MANAGER_TIMEOUT, CONN_MANAGER_TIMEOUT);
		parentParams.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, CONNECT_TIMEOUT);
		parentParams.setParameter(CoreConnectionPNames.SO_TIMEOUT, SOCKET_TIMEOUT);
		parentParams.setParameter(ClientPNames.ALLOW_CIRCULAR_REDIRECTS, true);
		parentParams.setParameter(ClientPNames.HANDLE_REDIRECTS, true);
		// 设置头信息,模拟浏览器，可省略
		// Collection<BasicHeader> collection = new ArrayList<BasicHeader>();
		// collection.add(new BasicHeader("User-Agent",
		// "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)"));
		// collection.add(new BasicHeader("Accept",
		// "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"));
		// collection.add(new BasicHeader("Accept-Language",
		// "zh-cn,zh,en-US,en;q=0.5"));
		// collection.add(new BasicHeader("Accept-Charset",
		// "ISO-8859-1,utf-8,gbk,gb2312;q=0.7,*;q=0.7"));
		// parentParams.setParameter(ClientPNames.DEFAULT_HEADERS, collection);

		return parentParams;
	}

	/**
	 * 初始化httpclient客户端
	 * 
	 * @param poolingClientConnectionManager
	 * @param httpParams
	 * @return
	 */
	private static void initHttpClient() {
		PoolingClientConnectionManager poolingClientConnectionManager = initPoolingClientConnectionManager();
		HttpParams httpParams = initHttpParams();

		SchemeRegistry schemeRegistry = poolingClientConnectionManager.getSchemeRegistry();
		schemeRegistry.register(new Scheme("http", 80, PlainSocketFactory.getSocketFactory()));
		schemeRegistry.register(new Scheme("https", 443, GatewaySSLSocketFactory.getSSLSocketFactory()));

		httpClient = new DefaultHttpClient(poolingClientConnectionManager, httpParams);
		httpClient.setHttpRequestRetryHandler(getHttpRequestRetryHandler());
	}

	/**
	 * 请求重试处理
	 * 
	 * @return
	 */
	private static HttpRequestRetryHandler getHttpRequestRetryHandler() {
		return new HttpRequestRetryHandler() {
			public boolean retryRequest(IOException exception, int executionCount, HttpContext context) {
				if (executionCount >= 5) {
					logger.info("网络请求尝试5次失败");
					return false;
				} else if (exception instanceof NoHttpResponseException) {
					logger.info("服务器链接丢失，重新请求");
					return true;
				} else if (exception instanceof SSLHandshakeException) {
					logger.info("SSL握手失败");
					return false;
				}

				HttpRequest request = (HttpRequest) context.getAttribute(ExecutionContext.HTTP_REQUEST);
				boolean idempotent = !(request instanceof HttpEntityEnclosingRequest);
				if (idempotent) {
					// 如果请求被认为是幂等的，那么就重试
					return true;
				}
				return false;
			}

		};
	}

	private static HttpClient getHttpClient() {
		return httpClient;
	}

	/**
	 * 设置请求的header头信息
	 * 
	 * @param httpRequest
	 * @param headerParams
	 */
	private static void setHeaderParams(HttpRequestBase httpRequest, Map<String, String> headerParams) {
		if ((headerParams != null) && (headerParams.size() > 0)) {
			Set<Entry<String, String>> entrySet = headerParams.entrySet();
			for (Entry<String, String> entry : entrySet) {
				httpRequest.setHeader((String) entry.getKey(), (String) entry.getValue());
			}
		}
	}

	/**
	 * get请求，返回字符串请求结果
	 * 
	 * @param httpUrl
	 *            请求url
	 * @return
	 */
	public static String doGet(String httpUrl) {
		return doGet(httpUrl, null, null);
	}

	/**
	 * get请求，返回字符串请求结果
	 * 
	 * @param httpUrl
	 *            请求url
	 * @param httpParams
	 *            请求参数集合
	 * @return
	 */
	public static String doGet(String httpUrl, Map<String, Object> httpParams) {
		return doGet(httpUrl, null, httpParams);
	}

	/**
	 * get请求，返回字符串请求结果
	 * 
	 * @param httpUrl
	 *            请求url
	 * @param headerParams
	 *            http请求的header参数集合
	 * @param httpParams
	 *            请求参数集合
	 * @return
	 */
	public static String doGet(String httpUrl, Map<String, String> headerParams, Map<String, Object> httpParams) {
		if (StringUtils.isBlank(httpUrl)) {
			return null;
		}
		HttpGet httpGet = null;
		try {
			HttpClient client = getHttpClient();

			StringBuffer params = new StringBuffer("?1=1");
			if ((httpParams != null) && (httpParams.size() > 0)) {
				Set<Entry<String, Object>> entrySet = httpParams.entrySet();
				for (Entry<String, Object> entry : entrySet) {
					params.append("&" + (String) entry.getKey() + "=" + (String) entry.getValue());
				}
			}

			httpGet = new HttpGet(httpUrl + params);
			setHeaderParams(httpGet, headerParams);

			HttpResponse response = client.execute(httpGet);

			HttpEntity resEntity = response.getEntity();
			String str = EntityUtils.toString(resEntity, DEFAULT_CHARSET);
			return str;
		} catch (Exception e) {
			logger.error("http get is error," + e.getMessage(), e);
		} finally {
			if(httpGet!=null){
				httpGet.releaseConnection();
			}
		}
		return null;
	}

	/**
	 * 生成Post请求所需要的参数对象
	 * 
	 * @param httpParams
	 * @return
	 * @throws UnsupportedEncodingException
	 */
	private static MultipartEntity getPostFileParamEntity(Map<String, Object> httpParams) throws UnsupportedEncodingException {
		MultipartEntity reqEntity = new MultipartEntity();
		if ((httpParams != null) && (httpParams.size() != 0)) {
			Set<Entry<String, Object>> entrySet = httpParams.entrySet();
			for (Entry<String, Object> entry : entrySet) {
				if ((entry.getValue() instanceof String)) {
					String value = entry.getValue().toString();
					String key = entry.getKey().toString();
					reqEntity.addPart(key, new StringBody(value));
				} else if ((entry.getValue() instanceof File)) {
					reqEntity.addPart((String) entry.getKey(), new FileBody((File) entry.getValue()));
				} else {
					logger.info("http params is unknown");
					return null;
				}
			}
		}
		return reqEntity;
	}

	/**
	 * 生成Post请求所需要的参数对象
	 * 
	 * @param httpParams
	 * @return
	 * @throws UnsupportedEncodingException
	 */
	private static StringEntity getPostParamEntity(Map<String, Object> httpParams) throws UnsupportedEncodingException {
		StringBuffer buf = new StringBuffer();
		if ((httpParams != null) && (httpParams.size() != 0)) {
			Set<Entry<String, Object>> entrySet = httpParams.entrySet();
			for (Entry<String, Object> entry : entrySet) {
				if ((entry.getValue() instanceof String)) {
					buf.append(entry.getKey()).append("=").append(entry.getValue()).append("&");
				}
			}
		}
		String data = buf.toString();
		if (data.length() > 0) {
			data = data.substring(0, data.length() - 1);
		}
		StringEntity strEntity = new StringEntity(data, DEFAULT_CHARSET);
		strEntity.setContentType("application/x-www-form-urlencoded; charset=UTF-8");
		return strEntity;
	}

	/**
	 * post请求，返回字符串请求结果
	 * 
	 * @param httpUrl
	 *            请求url
	 * @return
	 */
	public static String doPost(String httpUrl) {
		return doPost(httpUrl, null, null);
	}

	/**
	 * post请求，返回字符串请求结果
	 * 
	 * @param httpUrl
	 *            请求url
	 * @param httpParams
	 *            请求参数集合
	 * @return
	 */
	public static String doPost(String httpUrl, Map<String, Object> httpParams) {
		return doPost(httpUrl, null, httpParams);
	}

	
	
	/**
	 * post请求，返回字符串请求结果
	 * 
	 * @param httpUrl
	 *            请求url
	 * @param headerParams
	 *            http请求的header参数集合
	 * @param httpParams
	 *            请求参数集合
	 * @return
	 */
	public static String doPost(String httpUrl, Map<String, String> headerParams, Map<String, Object> httpParams) {
		return doPost(httpUrl, headerParams, httpParams, false);
	}

	
	
	/**
	 * post请求，返回字符串请求结果
	 * 
	 * @param httpUrl
	 *            请求url
	 * @param headerParams
	 *            http请求的header参数集合
	 * @param httpParams
	 *            请求参数集合
	 * @return
	 */
	public static String doPost(String httpUrl, Map<String, String> headerParams, Map<String, Object> httpParams, boolean containsFile) {
		if (StringUtils.isBlank(httpUrl)) {
			return null;
		}
		HttpPost httpPost = null;
		try {
			HttpClient client = getHttpClient();

			httpPost = new HttpPost(httpUrl);
			if (headerParams == null) {
				headerParams = new HashMap<String, String>();
			}
			headerParams.put("charset", DEFAULT_CHARSET);
			setHeaderParams(httpPost, headerParams);

			HttpEntity reqEntity = null;
			if (containsFile) {
				reqEntity = getPostFileParamEntity(httpParams);
			} else {
				reqEntity = getPostParamEntity(httpParams);
			}
			if (reqEntity == null) {
				return null;
			}
			httpPost.setEntity(reqEntity);

			HttpResponse response = client.execute(httpPost);

			PoolingClientConnectionManager manager = (PoolingClientConnectionManager) httpClient.getConnectionManager();
			logger.info("Pooling Client Connection Manager pending:" + manager.getTotalStats().getPending() + ";available:"
					+ manager.getTotalStats().getAvailable() + ";leased:" + manager.getTotalStats().getLeased());

			HttpEntity resEntity = response.getEntity();

			BufferedReader reader = new BufferedReader(new InputStreamReader(resEntity.getContent(), DEFAULT_CHARSET));
			StringBuffer sb = new StringBuffer();
			String line = null;
			while ((line = reader.readLine()) != null) {
				sb.append(line);
			}
			return sb.toString();
		} catch (Exception e) {
			logger.error("http post is error," + e.getMessage(), e);
			throw new SystemException(ErrorCode.SYSTEM_REQUEST_TIMEOUT,null,e);
		} finally {
			if(httpPost!=null){
				httpPost.releaseConnection();
			}
		}
	}
	
	
	public static String requestTencent(String httpUrl, Map<String, String> httpParams, Map<String, String> headerParams) {
		if (StringUtils.isBlank(httpUrl)) {
			return null;
		}
		HttpGet httpGet = null;
		try {
			HttpClient client = getHttpClient();
			StringBuffer params = new StringBuffer("?");
			if ((httpParams != null) && (httpParams.size() > 0)) {
				Set<Entry<String, String>> entrySet = httpParams.entrySet();
				for (Entry<String, String> entry : entrySet) {
					String value = (String) entry.getValue();
					if(StringUtils.isNotEmpty(value) ){
						value = URLEncoder.encode(value, "UTF-8");
					}
					params.append((String) entry.getKey() + "=" +value +"&" );
				}
			}
			String paramString = params.toString();
			paramString = paramString.substring(0, paramString.length()-1);
			
			logger.info("httpUrl + paramString," +httpUrl + paramString);
			
			httpGet = new HttpGet(httpUrl + paramString);
			setHeaderParams(httpGet, headerParams);
			
			HttpResponse response = client.execute(httpGet);
			HttpEntity resEntity = response.getEntity();
			String str = EntityUtils.toString(resEntity, DEFAULT_CHARSET);
			return str;
		} catch (Exception e) {
			logger.error("http get is error," + e.getMessage(), e);
		} finally {
			if(httpGet!=null){
				httpGet.releaseConnection();
			}
		}
		return null;
	}
	
	public static String getQueryString(Map<String, String> data) {
        if (data == null || data.isEmpty()) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        for (String key : data.keySet()) {
            sb.append(key).append("=").append(data.get(key)).append("&");
        }

        String text = sb.toString();
        if (text.endsWith("&")) {
            text = text.substring(0, text.length() - 1);
        }
        return text;
    }
	
}

class GatewaySSLSocketFactory {
	private static Logger log = LoggerFactory.getLogger(GatewaySSLSocketFactory.class);
	
	private static SSLSocketFactory sslSocketFactory = null;
	
	private GatewaySSLSocketFactory() {
	}
	
	/**
	 * 获得SSLSocketFactory
	 * @return
	 */
	public static synchronized SSLSocketFactory getSSLSocketFactory() {
		if(sslSocketFactory == null) {
			try {
				SSLContext ctx = SSLContext.getInstance(SSLSocketFactory.TLS);
				ctx.init(null, new TrustManager[] { new TrustAnyTrustManager() }, null);
				sslSocketFactory = new SSLSocketFactory(ctx);
			} catch (Exception e) {
				log.error("获取SSLSocket失败",e);
			}
		}
		return sslSocketFactory;
	}

	private static class TrustAnyTrustManager implements X509TrustManager {
		public void checkClientTrusted(X509Certificate[] chain, String authType)
				throws CertificateException {
		}

		public void checkServerTrusted(X509Certificate[] chain, String authType)
				throws CertificateException {
		}

		public X509Certificate[] getAcceptedIssuers() {
			return new X509Certificate[] {};
		}
	}
}
